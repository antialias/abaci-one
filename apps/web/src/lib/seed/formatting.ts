import type { SkillBktResult } from '../curriculum/bkt'
import type { TestStudentProfile, TuningRound } from './types'

/**
 * Format tuning history for notes
 */
export function formatTuningHistory(history: TuningRound[]): string {
  if (history.length <= 1) {
    return '' // No tuning needed
  }

  const lines: string[] = []
  lines.push('')
  lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
  lines.push('TUNING HISTORY')
  lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')

  for (const round of history) {
    lines.push('')
    lines.push(`Round ${round.round}:`)
    lines.push(
      `  Classifications: ðŸ”´ ${round.classifications.weak} weak, ðŸ“š ${round.classifications.developing} developing, âœ… ${round.classifications.strong} strong`
    )

    if (round.success) {
      lines.push(`  Result: âœ… Success`)
    } else {
      lines.push(`  Result: âŒ Failed`)
      for (const reason of round.failureReasons) {
        lines.push(`    - ${reason}`)
      }
      if (round.adjustmentsApplied.length > 0) {
        lines.push(`  Adjustments applied for next round:`)
        for (const adj of round.adjustmentsApplied) {
          lines.push(`    - ${adj}`)
        }
      }
    }
  }

  return lines.join('\n')
}

/**
 * Format BKT results into a human-readable summary for notes
 */
export function formatActualOutcomes(
  bktResult: { skills: SkillBktResult[] },
  profile: TestStudentProfile,
  tuningHistory?: TuningRound[]
): string {
  const skillsByClassification: Record<string, SkillBktResult[]> = {
    weak: [],
    developing: [],
    strong: [],
  }

  for (const skill of bktResult.skills) {
    if (skill.masteryClassification) {
      skillsByClassification[skill.masteryClassification].push(skill)
    }
  }

  const lines: string[] = []
  lines.push('')
  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
  lines.push('ACTUAL OUTCOMES (generated by seeder)')
  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
  lines.push('')
  lines.push(`BKT Classification Counts:`)
  lines.push(`  ðŸ”´ Weak: ${skillsByClassification.weak.length}`)
  lines.push(`  ðŸ“š Developing: ${skillsByClassification.developing.length}`)
  lines.push(`  âœ… Strong: ${skillsByClassification.strong.length}`)
  lines.push('')

  if (profile.expectedSessionMode) {
    lines.push(`Expected Session Mode: ${profile.expectedSessionMode.toUpperCase()}`)
    // Determine actual mode based on BKT
    let actualMode = 'maintenance'
    if (skillsByClassification.weak.length > 0) {
      actualMode = 'remediation'
    } else if (skillsByClassification.strong.length === profile.practicingSkills.length) {
      actualMode = 'progression'
    }
    const matches = actualMode === profile.expectedSessionMode ? 'âœ…' : 'âš ï¸'
    lines.push(`Actual Session Mode: ${actualMode.toUpperCase()} ${matches}`)
    lines.push('')
  }

  // List skills by classification with pKnown values
  if (skillsByClassification.weak.length > 0) {
    lines.push('Weak Skills (pKnown < 0.5):')
    for (const skill of skillsByClassification.weak) {
      lines.push(`  - ${skill.skillId}: ${(skill.pKnown * 100).toFixed(0)}%`)
    }
    lines.push('')
  }

  if (skillsByClassification.developing.length > 0) {
    lines.push('Developing Skills (0.5 â‰¤ pKnown < 0.8):')
    for (const skill of skillsByClassification.developing) {
      lines.push(`  - ${skill.skillId}: ${(skill.pKnown * 100).toFixed(0)}%`)
    }
    lines.push('')
  }

  if (skillsByClassification.strong.length > 0) {
    lines.push('Strong Skills (pKnown â‰¥ 0.8):')
    for (const skill of skillsByClassification.strong) {
      lines.push(`  - ${skill.skillId}: ${(skill.pKnown * 100).toFixed(0)}%`)
    }
    lines.push('')
  }

  lines.push(`Generated: ${new Date().toISOString()}`)

  // Add tuning history if present
  if (tuningHistory && tuningHistory.length > 0) {
    lines.push(formatTuningHistory(tuningHistory))
  }

  return lines.join('\n')
}
